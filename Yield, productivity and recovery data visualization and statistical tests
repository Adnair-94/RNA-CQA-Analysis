# ===============================================================
# FIGURE 2 — Yield & Productivity Panel (8 mL volume)
# ===============================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(patchwork)
  library(grid)
  library(ggtext)
  library(rstatix) 
})

outdir <- "fig_main"; dir.create(outdir, showWarnings = FALSE)

# ------------------ Toggle: ASCII fallbacks for units ------------------
USE_ASCII_UNITS <- FALSE
U_h_inv   <- if (USE_ASCII_UNITS) "h^-1"    else "h\u207B\u00B9"
U_mL_inv  <- if (USE_ASCII_UNITS) "mL^-1"   else "mL\u207B\u00B9"
U_rate    <- paste0("mg ", U_h_inv)
U_prod    <- paste0("mg ", U_mL_inv, " ", U_h_inv)

# ------------------ Theme ------------------
ad_theme <- theme(
  text = element_text(family = "Arial", size = 12, face = "bold"),
  rect = element_blank(),
  panel.grid = element_blank(),
  axis.line = element_line(color = "black", linewidth = 0.5),
  axis.ticks.length = unit(-0.15, "cm"),
  axis.ticks = element_line(colour = "black", linewidth = 0.5),
  axis.text.x = element_text(color = "black", size = 12,
                             margin = unit(c(t = 2.5, r = 0, b = 0, l = 0), "mm")),
  axis.text.y = element_text(color = "black", size = 12,
                             margin = unit(c(t = 0, r = 2.5, b = 0, l = 0), "mm")),
  panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.5),
  axis.title  = element_text(face = "bold", size = 12),
  axis.text   = element_text(face = "bold", size = 12),
  strip.text  = element_text(face = "bold", size = 12),
  legend.text = element_text(size = 12),
  legend.title= element_text(face = "bold", size = 12),
  legend.position = "bottom",
  legend.box = "horizontal",
  legend.justification = "center",
  legend.spacing.x = unit(20, "mm"),
  legend.key.width = unit(5, "mm"),
  legend.key.height = unit(5, "mm"),
  legend.margin = margin(t = 3, r = 0, b = 0, l = 0, unit = "mm")
)

# Fallback palette if not defined upstream
if (!exists("pal_io", inherits = FALSE)) {
  pal_io <- c("Crude RNA" = "grey70", "Purified RNA" = "grey30")
}

# ------------------ Load ------------------
raw <- readr::read_csv(
  "C://Users//CBE-User ZK02//OneDrive//Publication//IVT-Oligo-dT recycling//Graphs//Yield//Recycling yield and integrity.csv",
  show_col_types = FALSE
) %>%
  mutate(Cycle = factor(Cycle, levels = sort(unique(Cycle))),
         Replicate = factor(Replicate))

cols_needed <- c(
  "Input (NaCl Buffer)","Output (NaCl Buffer)",
  "Input (KoAc Buffer)","Output (KoAc Buffer)"
)
stopifnot(all(cols_needed %in% names(raw)))

# ------------------ Tidy ------------------
long <- raw %>%
  pivot_longer(cols = all_of(cols_needed), names_to = "Var", values_to = "Value") %>%
  mutate(
    Type = ifelse(grepl("^Input", Var), "Crude RNA", "Purified RNA"),
    Buffer_key = case_when(
      grepl("\\(NaCl Buffer\\)", Var)  ~ "NaCl",
      grepl("\\(KoAc Buffer\\)", Var)  ~ "CH3COOK"
    ),
    Buffer_lab = case_when(
      Buffer_key == "NaCl"    ~ "bold(NaCl~Buffer)",
      Buffer_key == "CH3COOK" ~ "bold(CH[3]*COOK~Buffer)"
    ),
    Value = as.numeric(Value)
  ) %>%
  mutate(
    Type       = factor(Type, levels = c("Crude RNA","Purified RNA")),
    Buffer_key = factor(Buffer_key, levels = c("CH3COOK","NaCl")),
    Buffer_lab = factor(Buffer_lab, levels = c("bold(CH[3]*COOK~Buffer)","bold(NaCl~Buffer)"))
  )

dodge_w <- 0.80

y_means <- long %>%
  group_by(Buffer_lab, Cycle, Type) %>%
  summarise(mean_mg = mean(Value, na.rm = TRUE), .groups = "drop")

# ------------------ Correct rate & productivity (8 mL) ------------------
reaction_volume_mL <- c("CH3COOK" = 8.00, "NaCl" = 8.00)  # both runs at 8 mL
cycle_time_h       <- c("CH3COOK" = 1.08,  "NaCl" = 2.17) # h (edit if needed)
prod_type <- "Purified RNA"

y_means_prod <- y_means %>%
  filter(Type == prod_type) %>%
  mutate(
    Buffer_key = case_when(
      Buffer_lab == "bold(NaCl~Buffer)"       ~ "NaCl",
      Buffer_lab == "bold(CH[3]*COOK~Buffer)" ~ "CH3COOK"
    ),
    rate_mg_per_h = mean_mg / cycle_time_h[Buffer_key],                 # mg h^-1
    prod_mg_mL_h  = rate_mg_per_h / reaction_volume_mL[Buffer_key]      # mg mL^-1 h^-1
  )

prod_overall <- y_means_prod %>%
  group_by(Buffer_lab, Buffer_key) %>%
  summarise(
    n_cycles        = dplyr::n(),
    total_yield_mg  = sum(mean_mg, na.rm = TRUE),
    total_time_h    = n_cycles * cycle_time_h[first(Buffer_key)],
    rate_overall    = total_yield_mg / total_time_h,                        # mg h^-1
    prod_overall    = rate_overall / reaction_volume_mL[first(Buffer_key)], # mg mL^-1 h^-1
    .groups = "drop"
  )

# Helper to format annotation text with explicit units
make_ann <- function(buf_lab_chr) {
  row_overall <- prod_overall %>% filter(Buffer_lab == buf_lab_chr)
  stopifnot(nrow(row_overall) == 1)
  time_per_cycle <- cycle_time_h[row_overall$Buffer_key]
  total_time     <- row_overall$total_time_h
  rate_str       <- sprintf(paste0("%.2f ", U_rate), row_overall$rate_overall)
  prod_str       <- sprintf(paste0("%.2f ", U_prod), row_overall$prod_overall)
  paste0(
    "<span style='display:inline-block;width:9.5ch;font-weight:600;'>Time per cycle:</span> ",
    sprintf("%.2f h", time_per_cycle), "<br/>",
    "<span style='display:inline-block;width:9.5ch;font-weight:600;'>Total process time:</span> ",
    sprintf("%.2f h", total_time), "<br/>",
    "<span style='display:inline-block;width:9.5ch;font-weight:600;'>Production Rate:</span> ", rate_str, "<br/>",
    "<span style='display:inline-block;width:9.5ch;font-weight:600;'>Productivity:</span> ", prod_str
  )
}

# ------------------ Annotation position (tweak x/y as needed) -------------
ann_text <- tibble(
  Buffer_lab = c("bold(CH[3]*COOK~buffer)","bold(NaCl~buffer)"),
  x = .55,    # move left/right
  y = 29.5,    # move up/down; your y-limits are 0..30
  label = c(make_ann("bold(CH[3]*COOK~Buffer)"),
            make_ann("bold(NaCl~Buffer)"))
)

# ------------------ Panel A: Yield per cycle ------------------
pA <- ggplot() +
  geom_col(
    data = y_means,
    aes(Cycle, mean_mg, fill = Type),
    position = position_dodge(width = dodge_w),
    width = 0.45, color = "black", linewidth = 0.4
  ) +
  geom_point(
    data = long,
    aes(Cycle, Value, group = Type),
    position = position_dodge(width = dodge_w),
    shape = 16, size = 2.0, alpha = 0.6, color = "black", show.legend = FALSE
  ) +
  facet_wrap(~ Buffer_lab, nrow = 1, labeller = label_parsed) +
  scale_fill_manual(values = pal_io, name = "Type") +
  scale_fill_manual(values = pal_io, name = NULL) +
  labs(x = "Cycle", y = "RNA yield (mg)") +
  scale_y_continuous(limits = c(0, 30), breaks = seq(0, 25, 5),
                     expand = expansion(mult = c(0, 0.02))) +
  ad_theme +
  theme(
    legend.position = "bottom",
    strip.text = element_text(family = "Arial", face = "plain"),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold", margin = margin(r = 3)),
    axis.text.x  = element_text(face = "bold"),
    axis.text.y  = element_text(face = "bold"),
    legend.box = "horizontal",
    legend.justification = "center",
    legend.spacing.x = unit(7.5, "mm"),      # horizontal gap between items
    legend.key.width = unit(5, "mm"),      # widen legend boxes
    legend.key.height = unit(5, "mm"),     # uniform box height
    
    # slight space between legend text and boxes
    legend.text = element_text( margin = margin(l = 2, r = 6, unit = "mm")),
    legend.box.spacing = unit(0, "mm")
  ) +
  ggtext::geom_richtext(
    data = ann_text,
    aes(x = x, y = y, label = label),
    hjust = 0, vjust = 1,
    size = 2.6,                      # <-- reduce to make smaller (e.g., 2.2)
    lineheight = 0.95,               # <-- tighten spacing if desired
    label.size = 0,
    label.padding = grid::unit(2, "pt"),
    label.r = grid::unit(0, "pt"),
    fill = "white", alpha = 0.85,
    family = "Arial"
  )

ggsave(file.path(outdir, "Figure2A_Yield.tiff"), pA,
       width = 180, height = 85, units = "mm", dpi = 600,
       compression = "lzw", bg = "white")

# ------------------ Panel B: Cumulative yield & recovery ------------------
cum_df <- tribble(
  ~Condition,           ~Yield_mg, ~Yield_sd, ~Recovery,
  "NaCl",                77.8,      6.1,       87,
  "CH3COOK",             68.7,      4.4,       85,
  "Standard process",    81.2,      1.5,       95
)

cond_scale <- scale_fill_manual(
  values = c("NaCl" = "grey70",
             "CH3COOK" = "grey40",
             "Standard process" = "grey10"),
  name = "Condition",
  labels = c("NaCl" = expression(NaCl),
             "CH3COOK" = expression(CH[3]*COOK),
             "Standard process" = "Standard process")
)

pB <- ggplot(cum_df, aes(y = Condition, x = Yield_mg, fill = Condition)) +
  geom_col(width = 0.55, color = "black") +
  geom_errorbar(
    aes(xmin = Yield_mg - Yield_sd, xmax = Yield_mg + Yield_sd, color = Condition),
    width = 0.3, linewidth = 0.4, show.legend = FALSE
  ) +
  scale_color_manual(values = c("NaCl" = "black",
                                "CH3COOK" = "black",
                                "Standard process" = "grey40")) +
  geom_point(aes(x = Recovery), size = 3.2, color = "black") +
  scale_x_continuous(
    name = "Cumulative yield (mg RNA)",
    sec.axis = sec_axis(~., name = "Recovery (%)"),
    limits = c(0, 100), expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_discrete(labels = c(
    "CH3COOK" = expression(bold(CH[3]*COOK)),
    "NaCl" = expression(bold(NaCl)),
    "Standard process" = expression(bold(Standard~process))
  )) +
  cond_scale +
  ad_theme +
  theme(
    legend.position = "none",
    axis.title.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_text(face = "bold"),
    axis.title.x.bottom = element_text(face = "bold"),
    axis.text.x.bottom  = element_text(face = "bold"),
    axis.title.x.top    = element_text(face = "bold", color = "black"),
    axis.text.x.top     = element_text(face = "bold", color = "black")
  )

ggsave(file.path(outdir, "Figure2B_Yield.tiff"), pB,
       width = 180, height = 50, units = "mm", dpi = 600,
       compression = "lzw", bg = "white")

# ------------------ Combine & Export ------------------
final_fig <- pA / pB + plot_layout(heights = c(2.5, 1))
ggsave(file.path(outdir, "Figure2_YieldProductivity.tiff"), final_fig,
       width = 180, height = 85, units = "mm", dpi = 600,
       compression = "lzw", bg = "white")

# ===============================================================
# Fluctuation metrics — with explicit units in headers
# ===============================================================
y_means_num <- y_means %>%
  mutate(Cycle_num = as.numeric(as.character(Cycle))) %>%
  arrange(Buffer_lab, Type, Cycle_num)

fluct_steps <- y_means_num %>%
  group_by(Buffer_lab, Type) %>%
  arrange(Cycle_num, .by_group = TRUE) %>%
  mutate(
    prev_mean      = lag(mean_mg),
    abs_change_mg  = mean_mg - prev_mean,
    rel_change_pct = ifelse(prev_mean == 0 | is.na(prev_mean),
                            NA_real_,
                            100 * abs_change_mg / prev_mean),
    step           = paste0("C", lag(Cycle_num), "→C", Cycle_num)
  ) %>%
  ungroup() %>%
  filter(!is.na(prev_mean)) %>%
  select(Buffer_lab, Type, step, abs_change_mg, rel_change_pct)

step_summary <- fluct_steps %>%
  group_by(Buffer_lab, Type) %>%
  summarise(
    mean_abs_delta_mg  = mean(abs(abs_change_mg), na.rm = TRUE),
    mean_abs_delta_pct = mean(abs(rel_change_pct),  na.rm = TRUE),
    sd_of_deltas_mg    = sd(abs_change_mg,          na.rm = TRUE),
    .groups = "drop"
  )

fluct_summary <- y_means_num %>%
  group_by(Buffer_lab, Type) %>%
  summarise(
    n_cycles                 = dplyr::n(),
    `mean_yield (mg)`       = mean(mean_mg, na.rm = TRUE),
    `sd_yield (mg)`         = sd(mean_mg,   na.rm = TRUE),
    `cv_yield (%)`          = 100 * `sd_yield (mg)` / `mean_yield (mg)`,
    `range_amp (mg)`        = diff(range(mean_mg, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  left_join(step_summary, by = c("Buffer_lab", "Type")) %>%
  mutate(
    `norm_cycle_fluct (%)`  = 100 * sd_of_deltas_mg / `mean_yield (mg)`,
    `range_over_mean (%)`   = 100 * `range_amp (mg)` / `mean_yield (mg)`
  )

fluct_summary_view <- fluct_summary %>%
  mutate(across(where(is.numeric), ~ round(., 2))) %>%
  arrange(Buffer_lab, Type)

fluct_summary_purified <- fluct_summary_view %>%
  filter(Type == "Purified RNA")

print(fluct_summary_view)
print(fluct_summary_purified)

# ------------------ Exports with explicit units in headers ------------------
readr::write_csv(fluct_steps,
                 file.path(outdir, "Yield_Fluctuation_PerStep.csv"))
readr::write_csv(fluct_summary_view,
                 file.path(outdir, "Yield_Fluctuation_Summary_AllTypes.csv"))
readr::write_csv(fluct_summary_purified,
                 file.path(outdir, "Yield_Fluctuation_Summary_Purified.csv"))

# ------------------ Optional: per-cycle & overall rate/productivity tables --
per_cycle_tbl <- y_means_prod %>%
  transmute(
    Buffer_lab, Cycle,
    `mean_yield (mg)`              = mean_mg,
    !!paste0("rate (", U_rate, ")")         := rate_mg_per_h,
    !!paste0("productivity (", U_prod, ")") := prod_mg_mL_h
  )

overall_tbl <- prod_overall %>%
  transmute(
    Buffer_lab, n_cycles,
    `total_yield (mg)`                    = total_yield_mg,
    `total_time (h)`                      = total_time_h,
    !!paste0("rate_overall (", U_rate, ")")         := rate_overall,
    !!paste0("productivity_overall (", U_prod, ")") := prod_overall
  )

readr::write_csv(per_cycle_tbl,
                 file.path(outdir, "PerCycle_Rate_Productivity.csv"))
readr::write_csv(overall_tbl,
                 file.path(outdir, "Overall_Rate_Productivity.csv"))
###############################################################################
# ===============================================================
# Statistics — Yield (nonparametric, robust; no data-file changes)
# ===============================================================
suppressPackageStartupMessages(library(rstatix))

# Purified-only, per-replicate observations
pur_long <- long %>%
  filter(Type == "Purified RNA") %>%
  transmute(Buffer = Buffer_key, Buffer_lab, Cycle, Replicate, Yield_mg = Value)

# ---------- (1) Within-buffer stability across cycles ----------
# Global: one-way Kruskal–Wallis per buffer
kw_within <- pur_long %>%
  group_by(Buffer) %>%
  do(kruskal_test(., Yield_mg ~ Cycle)) %>%
  ungroup() %>%
  add_significance()

# Post-hoc across cycles (only interpret if kw p < 0.05)
dunn_within <- pur_long %>%
  group_by(Buffer) %>%
  do(dunn_test(., Yield_mg ~ Cycle, p.adjust.method = "holm")) %>%
  ungroup()

# ---------- (2) Buffer comparison per cycle ----------
# Pairwise Mann–Whitney (NaCl vs CH3COOK) for each cycle + Holm correction
mw_per_cycle <- pur_long %>%
  group_by(Cycle) %>%
  wilcox_test(Yield_mg ~ Buffer, detailed = TRUE) %>%
  adjust_pvalue(method = "holm") %>%
  add_significance("p.adj") %>%
  ungroup()

# Effect size per cycle (Cliff's delta)
# ---- Cliff's delta per cycle via rstatix::pairwise_effsize ----
# ===============================================================
# Robust stats using base R + effsize (no rstatix dependence)
# ===============================================================
if (!requireNamespace("effsize", quietly = TRUE)) install.packages("effsize")
library(effsize)

# Helper to get Cliff's delta with CI, safely
.cliff_row <- function(x, y) {
  res <- effsize::cliff.delta(x, y, conf.level = 0.95)
  tibble::tibble(
    delta     = unname(res$estimate),
    magnitude = unname(res$magnitude),
    conf.low  = unname(res$conf.int[1]),
    conf.high = unname(res$conf.int[2])
  )
}

# ------------- (A) Per-cycle buffer comparison (NaCl vs CH3COOK) -------------
# Mann–Whitney p-values per cycle
mw_per_cycle <- pur_long %>%
  dplyr::group_by(Cycle) %>%
  dplyr::summarise(
    p = wilcox.test(Yield_mg ~ Buffer)$p.value,
    .groups = "drop"
  ) %>%
  dplyr::mutate(p.adj = p.adjust(p, method = "holm"),
                p.signif = dplyr::case_when(
                  p.adj < 0.001 ~ "***",
                  p.adj < 0.01  ~ "**",
                  p.adj < 0.05  ~ "*",
                  TRUE ~ "ns"
                ))

# Cliff's delta per cycle
delta_per_cycle <- pur_long %>%
  dplyr::group_by(Cycle) %>%
  dplyr::summarise(
    .cliff_row(Yield_mg[Buffer == "NaCl"], Yield_mg[Buffer == "CH3COOK"]),
    .groups = "drop"
  ) %>%
  dplyr::mutate(contrast = "NaCl vs CH3COOK")

# Join p-values + deltas
stats_per_cycle <- mw_per_cycle %>%
  dplyr::left_join(delta_per_cycle, by = "Cycle") %>%
  dplyr::select(Cycle, contrast, p, p.adj, p.signif, delta, magnitude, conf.low, conf.high)

readr::write_csv(stats_per_cycle, file.path(outdir, "stats_yield_per_cycle_buffers.csv"))

# ------------- (B) Cumulative yield (buffers only) -------------
cum_buf <- pur_long %>%
  dplyr::group_by(Buffer, Replicate) %>%
  dplyr::summarise(CumYield_mg = sum(Yield_mg), .groups = "drop")

# p-value (Mann–Whitney)
mw_cum_buffers <- wilcox.test(CumYield_mg ~ Buffer, data = cum_buf)

# Cliff's delta
x <- cum_buf$CumYield_mg[cum_buf$Buffer == "NaCl"]
y <- cum_buf$CumYield_mg[cum_buf$Buffer == "CH3COOK"]
cd <- effsize::cliff.delta(x, y, conf.level = 0.95)

stats_cum_buffers <- tibble::tibble(
  contrast = "NaCl vs CH3COOK",
  p        = unname(mw_cum_buffers$p.value),
  delta    = unname(cd$estimate),
  magnitude= unname(cd$magnitude),
  conf.low = unname(cd$conf.int[1]),
  conf.high= unname(cd$conf.int[2])
)

readr::write_csv(stats_cum_buffers, file.path(outdir, "stats_yield_cumulative_buffers.csv"))


# ---------- (3) Cumulative yield per replicate (buffers only) ----------
cum_buf <- pur_long %>%
  group_by(Buffer, Replicate) %>%
  summarise(CumYield_mg = sum(Yield_mg, na.rm = TRUE), .groups = "drop")

# Mann–Whitney on cumulative yield between buffers
mw_cum_buffers <- wilcox_test(cum_buf, CumYield_mg ~ Buffer, detailed = TRUE)

# ---------- (4) Optional: 3-group test incl. Standard (if replicate data available) ----------
# Provide a CSV with replicate-level standard yields (columns: Replicate, CumYield_mg)
STANDARD_YIELD_CSV <- "C://path//to//Standard_cumulative_yield_replicates.csv"
if (file.exists(STANDARD_YIELD_CSV)) {
  std_rep <- readr::read_csv(STANDARD_YIELD_CSV, show_col_types = FALSE) %>%
    transmute(Workflow = "Standard", Replicate = factor(Replicate), CumYield_mg)
  
  cum_three <- bind_rows(
    cum_buf %>% transmute(Workflow = as.character(Buffer), Replicate, CumYield_mg),
    std_rep
  ) %>%
    mutate(Workflow = factor(Workflow, levels = c("Standard","NaCl","CH3COOK")))
  
  # Omnibus (Kruskal–Wallis), effect size, and pairwise Dunn with Holm
  kw_three  <- kruskal_test(cum_three, CumYield_mg ~ Workflow) %>% add_significance()
  eta_three <- kruskal_effsize(cum_three, CumYield_mg ~ Workflow, ci = TRUE)
  dunn_three <- dunn_test(cum_three, CumYield_mg ~ Workflow, p.adjust.method = "holm") %>%
    add_significance("p.adj")
  
  readr::write_csv(kw_three,  file.path(outdir, "stats_yield_kw_three.csv"))
  readr::write_csv(eta_three, file.path(outdir, "stats_yield_eta_three.csv"))
  readr::write_csv(dunn_three,file.path(outdir, "stats_yield_dunn_three.csv"))
}

# ---------- Exports ----------
readr::write_csv(kw_within,          file.path(outdir, "stats_yield_kw_within.csv"))
readr::write_csv(dunn_within,        file.path(outdir, "stats_yield_dunn_within.csv"))
readr::write_csv(mw_per_cycle,       file.path(outdir, "stats_yield_mw_per_cycle.csv"))
readr::write_csv(delta_per_cycle,    file.path(outdir, "stats_yield_cliff_per_cycle.csv"))
readr::write_csv(cum_buf,            file.path(outdir, "stats_yield_cumulative_byrep_buffers.csv"))
readr::write_csv(mw_cum_buffers,     file.path(outdir, "stats_yield_mw_cumulative_buffers.csv"))

